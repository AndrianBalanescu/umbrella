import { Fn, Fn0, IDeref, IID, ILogger, NULL_LOGGER } from "@thi.ng/api";
import type { Transducer } from "@thi.ng/transducers";
import type { Stream } from "./stream";

export enum State {
    IDLE,
    ACTIVE,
    DONE,
    ERROR,
    DISABLED, // TODO currently unused
}

/**
 * Closing behaviors.
 */
export enum CloseMode {
    /**
     * Never close, even if no more inputs/outputs.
     */
    NEVER,
    /**
     * Close when first input/output is done / removed.
     */
    FIRST,
    /**
     * Close when last input/output is done / removed.
     */
    LAST,
}

/**
 * Common base options for all stream / subscription types.
 */
export interface CommonOpts {
    /**
     * Internal ID associated with this stream. If omitted, an
     * autogenerated ID will be used.
     */
    id: string;
    /**
     * If false or `CloseMode.NEVER`, the stream stays active even if
     * all inputs are done. If true (default) or `CloseMode.LAST`, the
     * stream closes when the last input is done. If `CloseMode.FIRST`,
     * the instance closes when the first input is done.
     *
     * @defaultValue CloseMode.LAST
     */
    closeIn: CloseMode;
    /**
     * If false or `CloseMode.NEVER`, the stream stays active once there
     * are no more subscribers. If true (default) or `CloseMode.LAST`,
     * the stream closes when the last subscriber has unsubscribed. If
     * `CloseMode.FIRST`, the instance closes when the first subscriber
     * disconnects.
     *
     * @defaultValue CloseMode.LAST
     */
    closeOut: CloseMode;
    /**
     * If true (default), stream caches last received value and pushes
     * it to new subscriberswhen they subscribe. If false, calling
     * `.deref()` on this stream will always return `undefined`.
     *
     * @defaultValue true
     */
    cache: boolean;
}

export interface WithTransform<A, B> {
    /**
     * Transducer to transform incoming stream values. If given, all
     * child subscriptions will only receive the transformed result
     * values.
     */
    xform: Transducer<A, B>;
}

export interface TransformableOpts<A, B>
    extends CommonOpts,
        WithTransform<A, B> {}

export type ErrorHandler = Fn<any, boolean>;

export interface WithErrorHandler {
    /**
     * Optional error handler to use for this
     */
    error: ErrorHandler;
}

export interface WithErrorHandlerOpts extends CommonOpts, WithErrorHandler {}

export interface SubscriptionOpts<A, B> extends TransformableOpts<A, B> {
    /**
     * Parent stream / subscription.
     */
    parent: ISubscription<any, A>;
}

export interface ISubscriber<T> {
    next: Fn<T, void>;
    error?: ErrorHandler;
    done?: Fn0<void>;
    /**
     * Internal use only. Do not use.
     */
    __owner?: ISubscription<any>;
    [id: string]: any;
}

export interface ISubscribable<A> extends IDeref<A | undefined>, IID<string> {
    /**
     * Adds given `sub` as child subscription.
     *
     * @param sub
     */
    subscribe<B>(sub: ISubscription<A, B>): ISubscription<A, B>;
    /**
     * Wraps given partial `sub` in a {@link Subscription} and attaches it as
     * child subscription.
     *
     * @param sub
     * @param opts
     */
    subscribe(
        sub: Partial<ISubscriber<A>>,
        opts?: Partial<CommonOpts>
    ): ISubscription<A, A>;
    /**
     * Wraps given partial `sub` in a {@link Subscription} and attaches it as
     * child subscription. If `opts` defines a transducer (via `xform` key),
     * input values will be transformed first before reaching the child sub's
     * {@link ISubsciber.next} handler. Any further downstream subscriptions
     * attached to the returned wrapped sub will also only receive those
     * transformed values.
     *
     * @see {@link ITransformable}
     *
     * @param sub
     * @param opts
     */
    subscribe<B>(
        sub: Partial<ISubscriber<B>>,
        opts?: Partial<TransformableOpts<A, B>>
    ): ISubscription<A, B>;
    /**
     * Removes given child sub, or if `sub` is omitted, detaches this
     * subscription itself from its upstream parent (possibly triggering a
     * cascade of further unsubscriptions, depending on
     * {@link CommonOpts.closeOut} settings of parent(s)).
     *
     * @param sub
     */
    unsubscribe(sub?: ISubscription<A, any>): boolean;
}

export interface ITransformable<B> {
    transform<C>(
        a: Transducer<B, C>,
        opts?: Partial<WithErrorHandlerOpts>
    ): ISubscription<B, C>;
    transform<C, D>(
        a: Transducer<B, C>,
        b: Transducer<C, D>,
        opts?: Partial<WithErrorHandlerOpts>
    ): ISubscription<B, D>;
    transform<C, D, E>(
        a: Transducer<B, C>,
        b: Transducer<C, D>,
        c: Transducer<D, E>,
        opts?: Partial<WithErrorHandlerOpts>
    ): ISubscription<B, E>;
    transform<C, D, E, F>(
        a: Transducer<B, C>,
        b: Transducer<C, D>,
        c: Transducer<D, E>,
        d: Transducer<E, F>,
        opts?: Partial<WithErrorHandlerOpts>
    ): ISubscription<B, F>;
    transform<C>(
        opts: WithTransform<B, C> & Partial<WithErrorHandlerOpts>
    ): ISubscription<B, C>;
}

export interface ISubscription<A = any, B = A>
    extends IDeref<B | undefined>,
        ISubscriber<A>,
        ISubscribable<B>,
        ITransformable<B> {
    parent?: ISubscription<any, A>;

    getState(): State;
}

export interface IStream<T> extends ISubscriber<T> {
    cancel: StreamCancel;
}

export type StreamCancel = () => void;
export type StreamSource<T> = (sub: Stream<T>) => StreamCancel | void;

export let LOGGER = NULL_LOGGER;

export const setLogger = (logger: ILogger) => (LOGGER = logger);

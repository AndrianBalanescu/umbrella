/**
 * Generated by @thi.ng/wasm-api at 2022-11-06T13:00:00.501Z - DO NOT EDIT!
 */

// @ts-ignore possibly includes unused imports
import { MemorySlice, Pointer, WasmStringSlice, WasmTypeBase, WasmTypeConstructor } from "@thi.ng/wasm-api";

export enum EventType {
	UNKOWN = -1,
	DRAG,
	FOCUS,
	INPUT,
	KEY,
	MOUSE,
	POINTER,
	SCROLL,
	TOUCH,
	WHEEL,
}

export enum MouseButton {
	NONE,
	PRIMARY = 1,
	SECONDARY = 2,
	MIDDLE = 4,
}

export enum PointerType {
	MOUSE,
	PEN,
	TOUCH,
}

export enum WheelDeltaMode {
	PIXEL,
	LINE,
	PAGE,
}

export enum KeyModifier {
	SHIFT = 1,
	CTRL = 2,
	ALT = 4,
	META = 8,
}

export interface WindowInfo extends WasmTypeBase {
	/**
	 * WASM type: u16
	 */
	innerWidth: number;
	/**
	 * WASM type: u16
	 */
	innerHeight: number;
	/**
	 * Horizontal scroll offset in fractional CSS pixels
	 * 
	 * WASM type: f32
	 */
	scrollX: number;
	/**
	 * Vertical scroll offset in fractional CSS pixels
	 * 
	 * WASM type: f32
	 */
	scrollY: number;
	/**
	 * Current device pixel ratio
	 * 
	 * WASM type: u8
	 */
	dpr: number;
	/**
	 * Encoded bitmask indicating fullscreen status / capability:
	 * - 1 (bit 0): fullscreen active
	 * - 2 (bit 1): fullscreen supported
	 * 
	 * WASM type: u8
	 */
	fullscreen: number;
}

export const $WindowInfo: WasmTypeConstructor<WindowInfo> = (mem) => ({
	get align() {
		return 4;
	},
	get size() {
		return 16;
	},
	instance: (base) => {
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 16);
			},
			get innerWidth(): number {
				return mem.u16[base >>> 1];
			},
			set innerWidth(x: number) {
				mem.u16[base >>> 1] = x;
			},
			get innerHeight(): number {
				return mem.u16[(base + 2) >>> 1];
			},
			set innerHeight(x: number) {
				mem.u16[(base + 2) >>> 1] = x;
			},
			get scrollX(): number {
				return mem.f32[(base + 4) >>> 2];
			},
			set scrollX(x: number) {
				mem.f32[(base + 4) >>> 2] = x;
			},
			get scrollY(): number {
				return mem.f32[(base + 8) >>> 2];
			},
			set scrollY(x: number) {
				mem.f32[(base + 8) >>> 2] = x;
			},
			get dpr(): number {
				return mem.u8[(base + 12)];
			},
			set dpr(x: number) {
				mem.u8[(base + 12)] = x;
			},
			get fullscreen(): number {
				return mem.u8[(base + 13)];
			},
			set fullscreen(x: number) {
				mem.u8[(base + 13)] = x;
			},
		};
	}
});

export interface DragEvent extends WasmTypeBase {
	/**
	 * Mouse X position in the local space of the element's bounding rect
	 * 
	 * WASM type: i16
	 */
	clientX: number;
	/**
	 * Mouse Y position in the local space of the element's bounding rect
	 * 
	 * WASM type: i16
	 */
	clientY: number;
	/**
	 * If non-zero, data that is being dragged during a drag & drop operation can be
	 * obtained via various DnD related API calls (only available when called from
	 * event handler).
	 * 
	 * WASM type: u8
	 */
	isDataTransfer: number;
	/**
	 * Encoded bitmask of currently pressed modifier keys, see `KeyModifier` enum
	 * 
	 * WASM type: u8
	 */
	modifiers: number;
	/**
	 * Encoded bitmask of all currently pressed mouse buttons, see `MouseButton`
	 * enum
	 * 
	 * WASM type: u8
	 */
	buttons: number;
	/**
	 * Event related mouse button ID (if any)
	 */
	button: MouseButton;
	
	fromEvent(e: globalThis.DragEvent): void;
}

export const $DragEvent: WasmTypeConstructor<DragEvent> = (mem) => ({
	get align() {
		return 2;
	},
	get size() {
		return 8;
	},
	instance: (base) => {
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 8);
			},
			get clientX(): number {
				return mem.i16[base >>> 1];
			},
			set clientX(x: number) {
				mem.i16[base >>> 1] = x;
			},
			get clientY(): number {
				return mem.i16[(base + 2) >>> 1];
			},
			set clientY(x: number) {
				mem.i16[(base + 2) >>> 1] = x;
			},
			get isDataTransfer(): number {
				return mem.u8[(base + 4)];
			},
			set isDataTransfer(x: number) {
				mem.u8[(base + 4)] = x;
			},
			get modifiers(): number {
				return mem.u8[(base + 5)];
			},
			set modifiers(x: number) {
				mem.u8[(base + 5)] = x;
			},
			get buttons(): number {
				return mem.u8[(base + 6)];
			},
			set buttons(x: number) {
				mem.u8[(base + 6)] = x;
			},
			get button(): MouseButton {
				return mem.u8[(base + 7)];
			},
			set button(x: MouseButton) {
				mem.u8[(base + 7)] = x;
			},
			
			fromEvent(e: globalThis.DragEvent) {
				const bounds = (<Element>(e.target)).getBoundingClientRect();
				this.clientX = e.clientX - bounds.left;
				this.clientY = e.clientY - bounds.top;
				this.buttons = e.buttons;
				this.button = e.button;
				this.isDataTransfer = e.dataTransfer ? 1 : 0;
			}
			
		};
	}
});

export interface InputEvent extends WasmTypeBase {
	/**
	 * Value of the targeted input element.
	 * The memory is owned by the DOM API and will be freed immediatedly after the
	 * event handler has returned.
	 */
	value: WasmStringSlice;
	/**
	 * Encoded bitmask of currently pressed modifier keys, see `KeyModifier` enum
	 * 
	 * WASM type: u8
	 */
	modifiers: number;
	
	fromEvent(e: globalThis.InputEvent): MemorySlice;
}

export const $InputEvent: WasmTypeConstructor<InputEvent> = (mem) => ({
	get align() {
		return 4;
	},
	get size() {
		return 12;
	},
	instance: (base) => {
		let $value: WasmStringSlice | null = null;
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 12);
			},
			get value(): WasmStringSlice {
				return $value || ($value = new WasmStringSlice(mem, base, true));
			},
			get modifiers(): number {
				return mem.u8[(base + 8)];
			},
			set modifiers(x: number) {
				mem.u8[(base + 8)] = x;
			},
			
			fromEvent(e: globalThis.InputEvent) {
				const el = <HTMLInputElement>e.target;
				const value = el.type === "checkbox" ? el.checked ? "on" : "off" : el.value;
				return this.value.setAlloc(value, false);
			}
			
		};
	}
});

export interface KeyEvent extends WasmTypeBase {
	/**
	 * Value/name of the key pressed
	 * 
	 * WASM type: [15:0]u8
	 */
	key: Uint8Array;
	/**
	 * Number of characters of the `key` string
	 * 
	 * WASM type: u8
	 */
	len: number;
	/**
	 * Encoded bitmask of currently pressed modifier keys, see `KeyModifier` enum
	 * 
	 * WASM type: u8
	 */
	modifiers: number;
	/**
	 * Non-zero value indicates key is being held down such that it's automatically
	 * repeating
	 * 
	 * WASM type: u8
	 */
	repeat: number;
	
	fromEvent(e: globalThis.KeyboardEvent): void;
}

export const $KeyEvent: WasmTypeConstructor<KeyEvent> = (mem) => ({
	get align() {
		return 1;
	},
	get size() {
		return 19;
	},
	instance: (base) => {
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 19);
			},
			get key(): Uint8Array {
				const addr = base;
				return mem.u8.subarray(addr, addr + 15);
			},
			get len(): number {
				return mem.u8[(base + 16)];
			},
			set len(x: number) {
				mem.u8[(base + 16)] = x;
			},
			get modifiers(): number {
				return mem.u8[(base + 17)];
			},
			set modifiers(x: number) {
				mem.u8[(base + 17)] = x;
			},
			get repeat(): number {
				return mem.u8[(base + 18)];
			},
			set repeat(x: number) {
				mem.u8[(base + 18)] = x;
			},
			
			fromEvent(e: globalThis.KeyboardEvent) {
				this.len = mem.setString(e.key, this.key.byteOffset, 16, true);
			}
			
		};
	}
});

export interface MouseEvent extends WasmTypeBase {
	/**
	 * Mouse X position in the local space of the element's bounding rect
	 * 
	 * WASM type: i16
	 */
	clientX: number;
	/**
	 * Mouse Y position in the local space of the element's bounding rect
	 * 
	 * WASM type: i16
	 */
	clientY: number;
	/**
	 * Encoded bitmask of currently pressed modifier keys, see `KeyModifier` enum
	 * 
	 * WASM type: u8
	 */
	modifiers: number;
	/**
	 * Encoded bitmask of all currently pressed mouse buttons, see `MouseButton`
	 * enum
	 * 
	 * WASM type: u8
	 */
	buttons: number;
	/**
	 * Event related mouse button ID (if any)
	 */
	button: MouseButton;
	
	fromEvent(e: globalThis.MouseEvent): void;
}

export const $MouseEvent: WasmTypeConstructor<MouseEvent> = (mem) => ({
	get align() {
		return 2;
	},
	get size() {
		return 8;
	},
	instance: (base) => {
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 8);
			},
			get clientX(): number {
				return mem.i16[base >>> 1];
			},
			set clientX(x: number) {
				mem.i16[base >>> 1] = x;
			},
			get clientY(): number {
				return mem.i16[(base + 2) >>> 1];
			},
			set clientY(x: number) {
				mem.i16[(base + 2) >>> 1] = x;
			},
			get modifiers(): number {
				return mem.u8[(base + 4)];
			},
			set modifiers(x: number) {
				mem.u8[(base + 4)] = x;
			},
			get buttons(): number {
				return mem.u8[(base + 5)];
			},
			set buttons(x: number) {
				mem.u8[(base + 5)] = x;
			},
			get button(): MouseButton {
				return mem.u8[(base + 6)];
			},
			set button(x: MouseButton) {
				mem.u8[(base + 6)] = x;
			},
			
			fromEvent(e: globalThis.MouseEvent) {
				const bounds = (<Element>(e.target)).getBoundingClientRect();
				this.clientX = e.clientX - bounds.left;
				this.clientY = e.clientY - bounds.top;
				this.buttons = e.buttons;
				this.button = e.button;
			}
			
		};
	}
});

export interface PointerEvent extends WasmTypeBase {
	/**
	 * Mouse X position in the local space of the element's bounding rect
	 * 
	 * WASM type: i16
	 */
	clientX: number;
	/**
	 * Mouse Y position in the local space of the element's bounding rect
	 * 
	 * WASM type: i16
	 */
	clientY: number;
	/**
	 * Unique pointer ID
	 * 
	 * WASM type: u32
	 */
	id: number;
	/**
	 * Normalized pressure value 0..1
	 * 
	 * WASM type: f32
	 */
	pressure: number;
	/**
	 * The plane angle (in degrees, in the range of -90 to 90) between the Yâ€“Z plane
	 * and the plane containing both the pointer (e.g. pen stylus) axis and the Y
	 * axis.
	 * 
	 * WASM type: i8
	 */
	tiltX: number;
	/**
	 * The plane angle (in degrees, in the range of -90 to 90) between the Xâ€“Z plane
	 * and the plane containing both the pointer (e.g. pen stylus) axis and the X
	 * axis.
	 * 
	 * WASM type: i8
	 */
	tiltY: number;
	/**
	 * The clockwise rotation of the pointer (e.g. pen stylus) around its major axis
	 * in degrees, with a value in the range 0 to 359.
	 * 
	 * WASM type: u16
	 */
	twist: number;
	pointerType: PointerType;
	/**
	 * Non-zero if event's pointer is the primary pointer (in a multitouch scenario)
	 * 
	 * WASM type: u8
	 */
	isPrimary: number;
	/**
	 * Encoded bitmask of currently pressed modifier keys, see `KeyModifier` enum
	 * 
	 * WASM type: u8
	 */
	modifiers: number;
	/**
	 * Encoded bitmask of all currently pressed mouse buttons, see `MouseButton`
	 * enum
	 * 
	 * WASM type: u8
	 */
	buttons: number;
	/**
	 * Event related mouse button ID (if any)
	 */
	button: MouseButton;
	
	fromEvent(e: globalThis.PointerEvent): void;
}

export const $PointerEvent: WasmTypeConstructor<PointerEvent> = (mem) => ({
	get align() {
		return 4;
	},
	get size() {
		return 24;
	},
	instance: (base) => {
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 24);
			},
			get clientX(): number {
				return mem.i16[base >>> 1];
			},
			set clientX(x: number) {
				mem.i16[base >>> 1] = x;
			},
			get clientY(): number {
				return mem.i16[(base + 2) >>> 1];
			},
			set clientY(x: number) {
				mem.i16[(base + 2) >>> 1] = x;
			},
			get id(): number {
				return mem.u32[(base + 4) >>> 2];
			},
			set id(x: number) {
				mem.u32[(base + 4) >>> 2] = x;
			},
			get pressure(): number {
				return mem.f32[(base + 8) >>> 2];
			},
			set pressure(x: number) {
				mem.f32[(base + 8) >>> 2] = x;
			},
			get tiltX(): number {
				return mem.i8[(base + 12)];
			},
			set tiltX(x: number) {
				mem.i8[(base + 12)] = x;
			},
			get tiltY(): number {
				return mem.i8[(base + 13)];
			},
			set tiltY(x: number) {
				mem.i8[(base + 13)] = x;
			},
			get twist(): number {
				return mem.u16[(base + 14) >>> 1];
			},
			set twist(x: number) {
				mem.u16[(base + 14) >>> 1] = x;
			},
			get pointerType(): PointerType {
				return mem.u8[(base + 16)];
			},
			set pointerType(x: PointerType) {
				mem.u8[(base + 16)] = x;
			},
			get isPrimary(): number {
				return mem.u8[(base + 17)];
			},
			set isPrimary(x: number) {
				mem.u8[(base + 17)] = x;
			},
			get modifiers(): number {
				return mem.u8[(base + 18)];
			},
			set modifiers(x: number) {
				mem.u8[(base + 18)] = x;
			},
			get buttons(): number {
				return mem.u8[(base + 19)];
			},
			set buttons(x: number) {
				mem.u8[(base + 19)] = x;
			},
			get button(): MouseButton {
				return mem.u8[(base + 20)];
			},
			set button(x: MouseButton) {
				mem.u8[(base + 20)] = x;
			},
			
			fromEvent(e: globalThis.PointerEvent) {
				const bounds = (<Element>(e.target)).getBoundingClientRect();
				this.clientX = e.clientX - bounds.left;
				this.clientY = e.clientY - bounds.top;
				this.tiltX = e.tiltX;
				this.tiltY = e.tiltY;
				this.twist = e.twist;
				this.isPrimary = ~~e.isPrimary;
				this.pointerType = PointerType[<"PEN">e.pointerType.toUpperCase()];
				this.buttons = e.buttons;
				this.button = e.button;
			}
			
		};
	}
});

export interface ScrollEvent extends WasmTypeBase {
	/**
	 * Horizontal scroll offset in fractional CSS pixels.
	 * 
	 * WASM type: f32
	 */
	scrollX: number;
	/**
	 * Vertical scroll offset in fractional CSS pixels.
	 * 
	 * WASM type: f32
	 */
	scrollY: number;
	
	fromEvent(e: globalThis.Event): void;
}

export const $ScrollEvent: WasmTypeConstructor<ScrollEvent> = (mem) => ({
	get align() {
		return 4;
	},
	get size() {
		return 8;
	},
	instance: (base) => {
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 8);
			},
			get scrollX(): number {
				return mem.f32[base >>> 2];
			},
			set scrollX(x: number) {
				mem.f32[base >>> 2] = x;
			},
			get scrollY(): number {
				return mem.f32[(base + 4) >>> 2];
			},
			set scrollY(x: number) {
				mem.f32[(base + 4) >>> 2] = x;
			},
			
			fromEvent(e: globalThis.Event) {
				const target = <HTMLElement>((<any>e.target).scrollTop != null ? e.target : document.scrollingElement);
				this.scrollX = target.scrollLeft || 0;
				this.scrollY = target.scrollTop || 0;
			}
			
		};
	}
});

export interface TouchEvent extends WasmTypeBase {
	/**
	 * Touch X position in the local space of the element's bounding rect
	 * 
	 * WASM type: i16
	 */
	clientX: number;
	/**
	 * Touch Y position in the local space of the element's bounding rect
	 * 
	 * WASM type: i16
	 */
	clientY: number;
	/**
	 * Encoded bitmask of currently pressed modifier keys, see `KeyModifier` enum
	 * 
	 * WASM type: u8
	 */
	modifiers: number;
	
	fromEvent(e: globalThis.TouchEvent): void;
}

export const $TouchEvent: WasmTypeConstructor<TouchEvent> = (mem) => ({
	get align() {
		return 2;
	},
	get size() {
		return 6;
	},
	instance: (base) => {
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 6);
			},
			get clientX(): number {
				return mem.i16[base >>> 1];
			},
			set clientX(x: number) {
				mem.i16[base >>> 1] = x;
			},
			get clientY(): number {
				return mem.i16[(base + 2) >>> 1];
			},
			set clientY(x: number) {
				mem.i16[(base + 2) >>> 1] = x;
			},
			get modifiers(): number {
				return mem.u8[(base + 4)];
			},
			set modifiers(x: number) {
				mem.u8[(base + 4)] = x;
			},
			
			fromEvent(e: globalThis.TouchEvent) {
				const bounds = (<Element>(e.target)).getBoundingClientRect();
				this.clientX = e.touches[0].clientX - bounds.left;
				this.clientY = e.touches[0].clientY - bounds.top;
			}
			
		};
	}
});

export interface WheelEvent extends WasmTypeBase {
	/**
	 * Scroll X delta
	 * 
	 * WASM type: i16
	 */
	deltaX: number;
	/**
	 * Scroll Y delta
	 * 
	 * WASM type: i16
	 */
	deltaY: number;
	/**
	 * Scroll Z delta
	 * 
	 * WASM type: i16
	 */
	deltaZ: number;
	/**
	 * Delta mode
	 */
	mode: WheelDeltaMode;
	/**
	 * Encoded bitmask of currently pressed modifier keys, see `KeyModifier` enum
	 * 
	 * WASM type: u8
	 */
	modifiers: number;
	/**
	 * Encoded bitmask of currently pressed mouse buttons, see `MouseButton` enum
	 * 
	 * WASM type: u8
	 */
	buttons: number;
	
	fromEvent(e: globalThis.WheelEvent): void;
}

export const $WheelEvent: WasmTypeConstructor<WheelEvent> = (mem) => ({
	get align() {
		return 2;
	},
	get size() {
		return 10;
	},
	instance: (base) => {
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 10);
			},
			get deltaX(): number {
				return mem.i16[base >>> 1];
			},
			set deltaX(x: number) {
				mem.i16[base >>> 1] = x;
			},
			get deltaY(): number {
				return mem.i16[(base + 2) >>> 1];
			},
			set deltaY(x: number) {
				mem.i16[(base + 2) >>> 1] = x;
			},
			get deltaZ(): number {
				return mem.i16[(base + 4) >>> 1];
			},
			set deltaZ(x: number) {
				mem.i16[(base + 4) >>> 1] = x;
			},
			get mode(): WheelDeltaMode {
				return mem.u8[(base + 6)];
			},
			set mode(x: WheelDeltaMode) {
				mem.u8[(base + 6)] = x;
			},
			get modifiers(): number {
				return mem.u8[(base + 7)];
			},
			set modifiers(x: number) {
				mem.u8[(base + 7)] = x;
			},
			get buttons(): number {
				return mem.u8[(base + 8)];
			},
			set buttons(x: number) {
				mem.u8[(base + 8)] = x;
			},
			
			fromEvent(e: globalThis.WheelEvent) {
				this.deltaX = e.deltaX;
				this.deltaY = e.deltaY;
				this.deltaZ = e.deltaZ;
				this.mode = e.deltaMode;
				this.buttons = e.buttons;
			}
			
		};
	}
});

export interface EventBody extends WasmTypeBase {
	drag: DragEvent;
	input: InputEvent;
	key: KeyEvent;
	mouse: MouseEvent;
	pointer: PointerEvent;
	scroll: ScrollEvent;
	touch: TouchEvent;
	wheel: WheelEvent;
}

export const $EventBody: WasmTypeConstructor<EventBody> = (mem) => ({
	get align() {
		return 4;
	},
	get size() {
		return 24;
	},
	instance: (base) => {
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 24);
			},
			get drag(): DragEvent {
				return $DragEvent(mem).instance(base);
			},
			set drag(x: DragEvent) {
				mem.u8.set(x.__bytes, base);
			},
			get input(): InputEvent {
				return $InputEvent(mem).instance(base);
			},
			set input(x: InputEvent) {
				mem.u8.set(x.__bytes, base);
			},
			get key(): KeyEvent {
				return $KeyEvent(mem).instance(base);
			},
			set key(x: KeyEvent) {
				mem.u8.set(x.__bytes, base);
			},
			get mouse(): MouseEvent {
				return $MouseEvent(mem).instance(base);
			},
			set mouse(x: MouseEvent) {
				mem.u8.set(x.__bytes, base);
			},
			get pointer(): PointerEvent {
				return $PointerEvent(mem).instance(base);
			},
			set pointer(x: PointerEvent) {
				mem.u8.set(x.__bytes, base);
			},
			get scroll(): ScrollEvent {
				return $ScrollEvent(mem).instance(base);
			},
			set scroll(x: ScrollEvent) {
				mem.u8.set(x.__bytes, base);
			},
			get touch(): TouchEvent {
				return $TouchEvent(mem).instance(base);
			},
			set touch(x: TouchEvent) {
				mem.u8.set(x.__bytes, base);
			},
			get wheel(): WheelEvent {
				return $WheelEvent(mem).instance(base);
			},
			set wheel(x: WheelEvent) {
				mem.u8.set(x.__bytes, base);
			},
		};
	}
});

export interface Event extends WasmTypeBase {
	id: EventType;
	/**
	 * Target element ID, > 1 if a known (WASM created) element, otherwise:
	 * 
	 * - -2: = unknown
	 * - -1: window
	 * - 0: document.head
	 * - 1: document.body
	 * 
	 * WASM type: i32
	 */
	target: number;
	/**
	 * Event details / payload. Currently, only the following event types have a
	 * defined body:
	 * 
	 * - drag
	 * - input
	 * - key
	 * - mouse
	 * - pointer
	 * - scroll
	 * - touch
	 * - wheel
	 */
	body: EventBody;
}

export const $Event: WasmTypeConstructor<Event> = (mem) => ({
	get align() {
		return 4;
	},
	get size() {
		return 32;
	},
	instance: (base) => {
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 32);
			},
			get id(): EventType {
				return mem.i32[base >>> 2];
			},
			set id(x: EventType) {
				mem.i32[base >>> 2] = x;
			},
			get target(): number {
				return mem.i32[(base + 4) >>> 2];
			},
			set target(x: number) {
				mem.i32[(base + 4) >>> 2] = x;
			},
			get body(): EventBody {
				return $EventBody(mem).instance((base + 8));
			},
			set body(x: EventBody) {
				mem.u8.set(x.__bytes, (base + 8));
			},
		};
	}
});

/**
 * DOM event listener
 */
export interface EventListener extends WasmTypeBase {
	/**
	 * Event listener function. Takes an event and optional pointer to user supplied
	 * arbitrary context data provided when registering the handler via
	 * `addListener()`
	 * 
	 * WASM type: u32
	 */
	callback: number;
	/**
	 * Optional type erased pointer to arbitrary user context. This pointer can be
	 * cast back into the desired type using this form:
	 * `@ptrCast(?*Foo, @alignCast(@alignOf(Foo), raw))`
	 * Also see: `wasmapi.ptrCast()`
	 * 
	 * WASM type: u32
	 */
	ctx: number;
}

export const $EventListener: WasmTypeConstructor<EventListener> = (mem) => ({
	get align() {
		return 4;
	},
	get size() {
		return 8;
	},
	instance: (base) => {
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 8);
			},
			get callback(): number {
				return mem.u32[base >>> 2];
			},
			set callback(x: number) {
				mem.u32[base >>> 2] = x;
			},
			get ctx(): number {
				return mem.u32[(base + 4) >>> 2];
			},
			set ctx(x: number) {
				mem.u32[(base + 4) >>> 2] = x;
			},
		};
	}
});

export interface CreateElementOpts extends WasmTypeBase {
	/**
	 * DOM element name
	 */
	tag: WasmStringSlice;
	/**
	 * Namespace URI or wellknown registered alias (e.g. svg, xlink, xmlns)
	 */
	ns: WasmStringSlice;
	/**
	 * ID attrib
	 */
	id: WasmStringSlice;
	/**
	 * Element class attrib
	 */
	class: WasmStringSlice;
	/**
	 * Element inner text body
	 */
	text: WasmStringSlice;
	/**
	 * Element inner HTML body
	 */
	html: WasmStringSlice;
	/**
	 * Parent element ID. If >=0 the new element will be attached to that parent
	 * element. Set to -1 to leave new element unattached (default unless nested)
	 * 
	 * WASM type: i32
	 */
	parent: number;
	/**
	 * Insertion index for new element or -1 to append (default)
	 * 
	 * WASM type: i32
	 */
	index: number;
	/**
	 * Optional slice of child element specs, which will be automatically attached
	 * as children to this element (their `parent` ID will be ignored)
	 */
	children: CreateElementOpts[];
	/**
	 * Optional slice of attribute definitions for this element. Also see provided
	 * `Attrib` factory fns for convenience.
	 */
	attribs: Attrib[];
}

export const $CreateElementOpts: WasmTypeConstructor<CreateElementOpts> = (mem) => ({
	get align() {
		return 4;
	},
	get size() {
		return 72;
	},
	instance: (base) => {
		let $tag: WasmStringSlice | null = null;
		let $ns: WasmStringSlice | null = null;
		let $id: WasmStringSlice | null = null;
		let $class: WasmStringSlice | null = null;
		let $text: WasmStringSlice | null = null;
		let $html: WasmStringSlice | null = null;
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 72);
			},
			get tag(): WasmStringSlice {
				return $tag || ($tag = new WasmStringSlice(mem, base, true));
			},
			get ns(): WasmStringSlice {
				return $ns || ($ns = new WasmStringSlice(mem, (base + 8), true));
			},
			get id(): WasmStringSlice {
				return $id || ($id = new WasmStringSlice(mem, (base + 16), true));
			},
			get class(): WasmStringSlice {
				return $class || ($class = new WasmStringSlice(mem, (base + 24), true));
			},
			get text(): WasmStringSlice {
				return $text || ($text = new WasmStringSlice(mem, (base + 32), true));
			},
			get html(): WasmStringSlice {
				return $html || ($html = new WasmStringSlice(mem, (base + 40), true));
			},
			get parent(): number {
				return mem.i32[(base + 48) >>> 2];
			},
			set parent(x: number) {
				mem.i32[(base + 48) >>> 2] = x;
			},
			get index(): number {
				return mem.i32[(base + 52) >>> 2];
			},
			set index(x: number) {
				mem.i32[(base + 52) >>> 2] = x;
			},
			get children(): CreateElementOpts[] {
				const len = mem.u32[(base + 60) >>> 2];
				const addr = mem.u32[(base + 56) >>> 2];
				const inst = $CreateElementOpts(mem);
				const slice: CreateElementOpts[] = [];
				for(let i = 0; i < len; i++) slice.push(inst.instance(addr + i * 72));
				return slice;
			},
			get attribs(): Attrib[] {
				const len = mem.u32[(base + 68) >>> 2];
				const addr = mem.u32[(base + 64) >>> 2];
				const inst = $Attrib(mem);
				const slice: Attrib[] = [];
				for(let i = 0; i < len; i++) slice.push(inst.instance(addr + i * 24));
				return slice;
			},
		};
	}
});

export interface Attrib extends WasmTypeBase {
	name: WasmStringSlice;
	value: AttribValue;
	kind: AttribType;
}

export const $Attrib: WasmTypeConstructor<Attrib> = (mem) => ({
	get align() {
		return 8;
	},
	get size() {
		return 24;
	},
	instance: (base) => {
		let $name: WasmStringSlice | null = null;
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 24);
			},
			get name(): WasmStringSlice {
				return $name || ($name = new WasmStringSlice(mem, base, true));
			},
			get value(): AttribValue {
				return $AttribValue(mem).instance((base + 8));
			},
			set value(x: AttribValue) {
				mem.u8.set(x.__bytes, (base + 8));
			},
			get kind(): AttribType {
				return mem.u8[(base + 16)];
			},
			set kind(x: AttribType) {
				mem.u8[(base + 16)] = x;
			},
		};
	}
});

export interface AttribValue extends WasmTypeBase {
	event: EventListener;
	/**
	 * WASM type: u8
	 */
	flag: number;
	/**
	 * WASM type: f64
	 */
	num: number;
	str: WasmStringSlice;
}

export const $AttribValue: WasmTypeConstructor<AttribValue> = (mem) => ({
	get align() {
		return 8;
	},
	get size() {
		return 8;
	},
	instance: (base) => {
		let $str: WasmStringSlice | null = null;
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 8);
			},
			get event(): EventListener {
				return $EventListener(mem).instance(base);
			},
			set event(x: EventListener) {
				mem.u8.set(x.__bytes, base);
			},
			get flag(): number {
				return mem.u8[base];
			},
			set flag(x: number) {
				mem.u8[base] = x;
			},
			get num(): number {
				return mem.f64[base >>> 3];
			},
			set num(x: number) {
				mem.f64[base >>> 3] = x;
			},
			get str(): WasmStringSlice {
				return $str || ($str = new WasmStringSlice(mem, base, true));
			},
		};
	}
});

export enum AttribType {
	EVENT,
	FLAG,
	NUM,
	STR,
}

export interface CreateCanvasOpts extends WasmTypeBase {
	/**
	 * Canvas width (in CSS pixels)
	 * 
	 * WASM type: u16
	 */
	width: number;
	/**
	 * Canvas height (in CSS pixels)
	 * 
	 * WASM type: u16
	 */
	height: number;
	/**
	 * Element ID attrib
	 */
	id: WasmStringSlice;
	/**
	 * Element class attrib
	 */
	class: WasmStringSlice;
	/**
	 * Same as CreateElementOpts.parent
	 * 
	 * WASM type: i32
	 */
	parent: number;
	/**
	 * Same as CreateElementOpts.index
	 * 
	 * WASM type: i32
	 */
	index: number;
	/**
	 * Device pixel ratio for computing physical pixel dimensions, see
	 * `getWindowInfo()`
	 * 
	 * WASM type: u8
	 */
	dpr: number;
	/**
	 * Optional slice of attribute definitions for this element. Also see provided
	 * `Attrib` factory fns for convenience.
	 */
	attribs: Attrib[];
}

export const $CreateCanvasOpts: WasmTypeConstructor<CreateCanvasOpts> = (mem) => ({
	get align() {
		return 4;
	},
	get size() {
		return 40;
	},
	instance: (base) => {
		let $id: WasmStringSlice | null = null;
		let $class: WasmStringSlice | null = null;
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 40);
			},
			get width(): number {
				return mem.u16[base >>> 1];
			},
			set width(x: number) {
				mem.u16[base >>> 1] = x;
			},
			get height(): number {
				return mem.u16[(base + 2) >>> 1];
			},
			set height(x: number) {
				mem.u16[(base + 2) >>> 1] = x;
			},
			get id(): WasmStringSlice {
				return $id || ($id = new WasmStringSlice(mem, (base + 4), true));
			},
			get class(): WasmStringSlice {
				return $class || ($class = new WasmStringSlice(mem, (base + 12), true));
			},
			get parent(): number {
				return mem.i32[(base + 20) >>> 2];
			},
			set parent(x: number) {
				mem.i32[(base + 20) >>> 2] = x;
			},
			get index(): number {
				return mem.i32[(base + 24) >>> 2];
			},
			set index(x: number) {
				mem.i32[(base + 24) >>> 2] = x;
			},
			get dpr(): number {
				return mem.u8[(base + 28)];
			},
			set dpr(x: number) {
				mem.u8[(base + 28)] = x;
			},
			get attribs(): Attrib[] {
				const len = mem.u32[(base + 36) >>> 2];
				const addr = mem.u32[(base + 32) >>> 2];
				const inst = $Attrib(mem);
				const slice: Attrib[] = [];
				for(let i = 0; i < len; i++) slice.push(inst.instance(addr + i * 24));
				return slice;
			},
		};
	}
});

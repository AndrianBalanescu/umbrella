//! Generated by @thi.ng/wasm-api at 2022-10-29T20:12:33.228Z - DO NOT EDIT!

const std = @import("std");

pub const EventType = enum(i32) {
    UNKOWN = -1,
    DRAG,
    FOCUS,
    INPUT,
    KEY,
    MOUSE,
    POINTER,
    SCROLL,
    TOUCH,
    WHEEL,
};

pub const MouseButton = enum(u8) {
    NONE,
    PRIMARY = 1,
    SECONDARY = 2,
    MIDDLE = 4,
};

pub const PointerType = enum(u8) {
    MOUSE,
    PEN,
    TOUCH,
};

pub const WheelDeltaMode = enum(u8) {
    PIXEL,
    LINE,
    PAGE,
};

pub const KeyModifier = enum(u8) {
    SHIFT = 1,
    CTRL = 2,
    ALT = 4,
    META = 8,
};

pub const WindowInfo = struct {
    innerWidth: u16,
    innerHeight: u16,
    /// Horizontal scroll offset in fractional CSS pixels
    scrollX: f32,
    /// Vertical scroll offset in fractional CSS pixels
    scrollY: f32,
    /// Current device pixel ratio
    dpr: u8,
    /// Encoded bitmask indicating fullscreen status / capability:
    /// - 1 (bit 0): fullscreen active
    /// - 2 (bit 1): fullscreen supported
    fullscreen: u8,
    
    /// Returns true if fullscreen mode is currently active (see `.fullscreen`)
    pub inline fn isFullscreen(self: *const WindowInfo) bool {
        return self.fullscreen & 1 != 0;
    }
    
    /// Returns true if fullscreen mode is supported (see `.fullscreen`)
    pub inline fn hasFullscreen(self: *const WindowInfo) bool {
        return self.fullscreen & 2 != 0;
    }
    
};

pub const DragEvent = struct {
    /// Mouse X position in the local space of the element's bounding rect
    clientX: i16 = 0,
    /// Mouse Y position in the local space of the element's bounding rect
    clientY: i16 = 0,
    /// If non-zero, data that is being dragged during a drag & drop operation can
    /// be obtained via various DnD related API calls (only available when called
    /// from event handler).
    isDataTransfer: u8 = 0,
    /// Encoded bitmask of currently pressed modifier keys, see `KeyModifier` enum
    modifiers: u8 = 0,
    /// Encoded bitmask of all currently pressed mouse buttons, see `MouseButton`
    /// enum
    buttons: u8 = 0,
    /// Event related mouse button ID (if any)
    button: MouseButton,
};

pub const InputEvent = struct {
    /// Value of the targeted input element.
    /// The memory is owned by the DOM API and will be freed immediatedly after the
    /// event handler has returned.
    value: []const u8,
    /// Encoded bitmask of currently pressed modifier keys, see `KeyModifier` enum
    modifiers: u8 = 0,
};

pub const KeyEvent = struct {
    /// Value/name of the key pressed
    key: [15:0]u8,
    /// Number of characters of the `key` string
    len: u8 = 0,
    /// Encoded bitmask of currently pressed modifier keys, see `KeyModifier` enum
    modifiers: u8 = 0,
    /// Non-zero value indicates key is being held down such that it's automatically
    /// repeating
    repeat: u8 = 0,
    
    pub inline fn getKey(self: *const KeyEvent) []const u8 {
        return self.key[0..@as(usize, self.len)];
    }
    
    pub inline fn hasModifier(self: *const KeyEvent, mod: KeyModifier) bool {
        return self.modifiers & @enumToInt(mod) != 0;
    }
    
};

pub const MouseEvent = struct {
    /// Mouse X position in the local space of the element's bounding rect
    clientX: i16 = 0,
    /// Mouse Y position in the local space of the element's bounding rect
    clientY: i16 = 0,
    /// Encoded bitmask of currently pressed modifier keys, see `KeyModifier` enum
    modifiers: u8 = 0,
    /// Encoded bitmask of all currently pressed mouse buttons, see `MouseButton`
    /// enum
    buttons: u8 = 0,
    /// Event related mouse button ID (if any)
    button: MouseButton,
};

pub const PointerEvent = struct {
    /// Mouse X position in the local space of the element's bounding rect
    clientX: i16 = 0,
    /// Mouse Y position in the local space of the element's bounding rect
    clientY: i16 = 0,
    /// Unique pointer ID
    id: u32 = 0,
    /// Normalized pressure value 0..1
    pressure: f32 = 0,
    /// The plane angle (in degrees, in the range of -90 to 90) between the Y–Z
    /// plane and the plane containing both the pointer (e.g. pen stylus) axis and
    /// the Y axis.
    tiltX: i8 = 0,
    /// The plane angle (in degrees, in the range of -90 to 90) between the X–Z
    /// plane and the plane containing both the pointer (e.g. pen stylus) axis and
    /// the X axis.
    tiltY: i8 = 0,
    /// The clockwise rotation of the pointer (e.g. pen stylus) around its major
    /// axis in degrees, with a value in the range 0 to 359.
    twist: u16 = 0,
    pointerType: PointerType,
    /// Non-zero if event's pointer is the primary pointer (in a multitouch
    /// scenario)
    isPrimary: u8,
    /// Encoded bitmask of currently pressed modifier keys, see `KeyModifier` enum
    modifiers: u8 = 0,
    /// Encoded bitmask of all currently pressed mouse buttons, see `MouseButton`
    /// enum
    buttons: u8 = 0,
    /// Event related mouse button ID (if any)
    button: MouseButton,
};

pub const ScrollEvent = struct {
    scrollX: f32,
    scrollY: f32,
};

pub const TouchEvent = struct {
    /// Touch X position in the local space of the element's bounding rect
    clientX: i16 = 0,
    /// Touch Y position in the local space of the element's bounding rect
    clientY: i16 = 0,
    /// Encoded bitmask of currently pressed modifier keys, see `KeyModifier` enum
    modifiers: u8 = 0,
};

pub const WheelEvent = struct {
    /// Scroll X delta
    deltaX: i16 = 0,
    /// Scroll Y delta
    deltaY: i16 = 0,
    /// Scroll Z delta
    deltaZ: i16 = 0,
    /// Delta mode
    mode: WheelDeltaMode,
    /// Encoded bitmask of currently pressed modifier keys, see `KeyModifier` enum
    modifiers: u8 = 0,
    /// Encoded bitmask of currently pressed mouse buttons, see `MouseButton` enum
    buttons: u8 = 0,
};

pub const EventBody = union {
    drag: DragEvent,
    input: InputEvent,
    key: KeyEvent,
    mouse: MouseEvent,
    pointer: PointerEvent,
    scroll: ScrollEvent,
    touch: TouchEvent,
    wheel: WheelEvent,
};

pub const Event = struct {
    id: EventType,
    /// Target element ID, positive if a known element, otherwise:
    /// 
    /// - 0: document.body
    /// - -1: window
    /// - -2: = unknown
    target: i32,
    /// Event details / payload. Currently, only the following event types have a
    /// defined body:
    /// 
    /// - input
    /// - key
    /// - mouse
    /// - pointer
    /// - scroll
    /// - touch
    /// - wheel
    body: EventBody,
};

pub const CreateElementOpts = struct {
    /// DOM element name
    tag: []const u8,
    /// Namespace URI or wellknown registered alias (e.g. svg, xlink, xmlns)
    ns: []const u8 = "",
    /// ID attrib
    id: []const u8 = "",
    /// Element class attrib
    class: []const u8 = "",
    /// Element inner text body
    text: []const u8 = "",
    /// Element inner HTML body
    html: []const u8 = "",
    /// Parent element ID. If >=0 the new element will be attached to that parent
    /// element. Set to -1 to leave new element unattached (default unless nested)
    parent: i32 = -1,
    /// Insertion index for new element or -1 to append (default)
    index: i32 = -1,
children: []const CreateElementOpts = &.{},
};

pub const CreateCanvasOpts = struct {
    /// Canvas width (in CSS pixels)
    width: u16,
    /// Canvas height (in CSS pixels)
    height: u16,
    /// Element ID attrib
    id: []const u8 = "",
    /// Element class attrib
    class: []const u8 = "",
    /// Same as CreateElementOpts.parent
    parent: i32,
    /// Same as CreateElementOpts.index
    index: i32 = -1,
    /// Device pixel ratio for computing physical pixel dimensions, see
    /// `getWindowInfo()`
    dpr: u8 = 1,
};
